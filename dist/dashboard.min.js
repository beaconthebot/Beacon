/*
 * Copyright © 2016 I.B.M. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the “License”);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* The Common module is designed as an auxiliary module
 * to hold functions that are used in multiple other modules
 * and functions that do not fit into the scopes of other modules
 */

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Common$" }] */
 function accounType (response){
console.log(response);
var res=response;

   var context;
      var latestResponse = Api.getWatsonPayload();
      if (latestResponse) {
        context = latestResponse.context;
      }

      // Send the user message
      Api.postConversationMessage(res, context);

}
 var timoutWarning = 60000;
var warningTimer;
  function StartTimers() {
    warningTimer = setTimeout("delay()", timoutWarning);
  }
  
  function ResetTimers() {
    clearTimeout(warningTimer);
    
    
  }
	
  function delay()
  {
	          Api.setWatsonPayload({output: {text: [
          'User! You have been idle for the past minute. You can ask me the queries on Breast cancer'
        ]}});
		ResetTimers();
  }
var Common = (function() {
  var classes = {
    hide: 'hide',
    fade: 'fade',
    fadeOut: 'fade-out'
  };

  // Publicly accessible methods defined
  return {
    buildDomElement: buildDomElementFromJson,
    wait: wait,
    fireEvent: fireEvent,
    listForEach: listForEach,
    partial: partial,
    hide: hide,
    show: show,
    toggle: toggle,
    fadeOut: fadeOut,
    fadeIn: fadeIn,
    fadeToggle: fadeToggle,
    addClass: addClass,
    removeClass: removeClass,
    toggleClass: toggleClass
  };

 
  function buildDomElementFromJson(domJson) {
    // Create a DOM element with the given tag name
    var element = document.createElement(domJson.tagName);

    // Fill the "content" of the element
    if (domJson.text) {
      element.textContent = domJson.text;
    } else if (domJson.html) {
      element.insertAdjacentHTML('beforeend', domJson.html);
    }

    // Add classes to the element
    if (domJson.classNames) {
      for (var i = 0; i < domJson.classNames.length; i++) {
        Common.addClass(element, domJson.classNames[i]);
      }
    }
    // Add attributes to the element
    if (domJson.attributes) {
      for (var j = 0; j < domJson.attributes.length; j++) {
        var currentAttribute = domJson.attributes[j];
        element.setAttribute(currentAttribute.name, currentAttribute.value);
      }
    }
    // Add children elements to the element
    if (domJson.children) {
      for (var k = 0; k < domJson.children.length; k++) {
        var currentChild = domJson.children[k];
        element.appendChild(buildDomElementFromJson(currentChild));
      }
    }
    return element;
  }

  // Wait until a condition is true until running a function
  // (poll based on interval in ms)
  function wait(conditionFunction, execFunction, interval) {
    if (!conditionFunction()) {
      setTimeout(function() {
        wait(conditionFunction, execFunction, interval);
      }, interval);
    } else {
      execFunction();
    }
  }

  // Triggers an event of the given type on the given object
  function fireEvent(element, event) {
    var evt;
    if (document.createEventObject) {
      // dispatch for IE
      evt = document.createEventObject();
      return element.fireEvent('on' + event, evt);
    }
    // otherwise, dispatch for Firefox, Chrome + others
    evt = document.createEvent('HTMLEvents');
    evt.initEvent(event, true, true); // event type,bubbling,cancelable
    return !element.dispatchEvent(evt);
  }

  // A function that runs a for each loop on a List, running the callback function for each one
  function listForEach(list, callback) {
    for (var i = 0; i < list.length; i++) {
      callback.call(null, list[i]);
    }
  }

  function partial(func /* , any number of bound args...*/) {
    var sliceFunc = Array.prototype.slice;
    var args = sliceFunc.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(sliceFunc.call(arguments, 0)));
    };
  }

  // Adds the 'hide' class to a given element, giving it a CSS display value of 'none'
  function hide(element) {
    addClass(element, classes.hide);
  }

  // Removes the 'hide' class from a given element, removing its CSS display value of 'none'
  function show(element) {
    removeClass(element, classes.hide);
  }

  // Toggles the 'hide' class on a given element, toggling a CSS display value of 'none'
  function toggle(element) {
    toggleClass(element, classes.hide);
  }

  // Causes an element to fade out by adding the 'fade' and 'fade-out' classes
  function fadeOut(element) {
    addClass(element, classes.fade);
    addClass(element, classes.fadeOut);
  }

  // Causes an element to fade back in by adding the 'fade' class and removing the 'fade-out' class
  function fadeIn(element) {
    addClass(element, classes.fade);
    removeClass(element, classes.fadeOut);
  }

  // Causes an element to toggle fading out or back in
  // by adding the 'fade' class and toggling the 'fade-out' class
  function fadeToggle(element) {
    addClass(element, classes.fade);
    toggleClass(element, classes.fadeOut);
  }

  // Auxiliary function for adding a class to an element
  // (to help mitigate IE's lack of support for svg.classList)
  function addClass(element, clazz) {
    if (element.classList) {
      element.classList.add(clazz);
    } else {
      ieSvgAddClass(element, clazz);
    }
  }

  // Auxiliary function for removing a class from an element
  // (to help mitigate IE's lack of support for svg.classList)
  function removeClass(element, clazz) {
    if (element.classList) {
      element.classList.remove(clazz);
    } else {
      ieSvgRemoveClass(element, clazz);
    }
  }

  // Auxiliary function for toggling a class on an element
  // (to help mitigate IE's lack of support for svg.classList)
  function toggleClass(element, clazz) {
    if (element.classList) {
      element.classList.toggle(clazz);
    } else {
      ieSvgToggleClass(element, clazz);
    }
  }


  // Auxiliary function for adding a class to an element without using the classList property
  // (to help mitigate IE's lack of support for svg.classList)



}());



var Api = (function() {
  'use strict';
  var userPayload;
  var watsonPayload;
  var context;

  var messageEndpoint = '/api/message';

  // Publicly accessible methods defined
  return {
    initConversation: initConversation,
    postConversationMessage: postConversationMessage,

    // The request/response getters/setters are defined here to prevent internal methods
    // from calling the methods without any of the callbacks that are added elsewhere.
    getUserPayload: function() {
      return userPayload;
    },
    setUserPayload: function(payload) {
      userPayload = payload;
    },
    getWatsonPayload: function() {
      return watsonPayload;
    },
    setWatsonPayload: function(payload) {
      watsonPayload = payload;
    }
  };

  // Function used for initializing the conversation with the first message from Watson
  function initConversation() {
    postConversationMessage('');
			ResetTimers();
	StartTimers();
  }

  // Send a message request to the server
  function postConversationMessage(text) {
    var data = {'input': {'text': text}};
    if (context) {
      data.context = context;
    }
    Api.setUserPayload(data);
    var http = new XMLHttpRequest();
    http.open('POST', messageEndpoint, true);
    http.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    http.onload = function() {
      if (http.status === 200 && http.responseText) {
        var response = JSON.parse(http.responseText);
        context = response.context;
        Api.setWatsonPayload(response);
      } else {
        Api.setWatsonPayload({output: {text: [
          'The service may be down at the moment; please check' +
          ' <a href="https://status.ng.bluemix.net/" target="_blank">here</a>' +
          ' for the current status. <br> If the service is OK,' +
          ' the app may not be configured correctly,' +
          ' please check workspace id and credentials for typos. <br>' +
          ' If the service is running and the app is configured correctly,' +
          ' try refreshing the page and/or trying a different request.'
        ]}});
        console.error('Server error when trying to reply!');
      }
    };
    http.onerror = function() {
      console.error('Network error trying to send message!');
    };

    http.send(JSON.stringify(data));
  }
}());








var Conversation = (function() {
  'use strict';
  var ids = {
    userInput: 'user-input',
    userInputDummy: 'user-input-dummy',
    chatFlow: 'chat-flow',
    chatScrollWrapper: 'chat-scroll-wrapper'
  };
  var classes = {
    messageWrapper: 'message-wrapper',
    preBar: 'pre-bar',
    underline: 'underline'
  };
  var authorTypes = {
    user: 'user',
    watson: 'watson'
  };

  // Publicly accessible methods defined
  return {
    init: init,
    setMessage: setMessage,
    sendMessage: sendMessage,
    focusInput: focusInput
  };

  // Initialize Conversation module
  function init() {
    chatSetup();
    initEnterSubmit();
    setupInputBox();
  }

  // Hide chat box until there are messages,
  // set up messages to display when user or Watson sends message
  function chatSetup() {
   // document.getElementById(ids.chatScrollWrapper).style.display = 'none';

    var currentRequestPayloadSetter = Api.setUserPayload;
    Api.setUserPayload = function(payload) {
      currentRequestPayloadSetter.call(Api, payload);
      displayMessage(payload, authorTypes.user);
    };

    var currentResponsePayloadSetter = Api.setWatsonPayload;
    Api.setWatsonPayload = function(payload) {
      currentResponsePayloadSetter.call(Api, payload);
      displayMessage(payload, authorTypes.watson);
    };
  }

  // Set up the input box to submit a message when enter is pressed
  function initEnterSubmit() {
    document.getElementById(ids.userInput)
        .addEventListener('keypress', function(event) {
          if (event.keyCode === 13) {
            sendMessage();
            event.preventDefault();
          }
        }, false);
  }

  // Set up the input box to underline text as it is typed
  // This is done by creating a hidden dummy version of the input box that
  // is used to determine what the width of the input text should be.
  // This value is then used to set the new width of the visible input box.
  function setupInputBox() {
    var input = document.getElementById(ids.userInput);
    var dummy = document.getElementById(ids.userInputDummy);
    var minFontSize = 9;
    var maxFontSize = 16;
    var minPadding = 5;
    var maxPadding = 9;

    // If no dummy input box exists, create one
    if (dummy === null) {
      var dummyJson = {
        'tagName': 'div',
        'attributes': [{
          'name': 'id',
          'value': (ids.userInputDummy)
        }]
      };

      dummy = Common.buildDomElement(dummyJson);
      document.body.appendChild(dummy);
    }

    function adjustInput() {
      if (input.value === '') {
        // If the input box is empty, remove the underline
        Common.removeClass(input, 'underline');
        input.setAttribute('style', 'width:' + '100%');
        input.style.width = '100%';
      } else {
        // otherwise, adjust the dummy text to match, and then set the width of
        // the visible input box to match it (thus extending the underline)
        Common.addClass(input, classes.underline);
        var txtNode = document.createTextNode(input.value);
        ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height',
          'text-transform', 'letter-spacing'].forEach(function(index) {
            dummy.style[index] = window.getComputedStyle(input, null).getPropertyValue(index);
          });
        dummy.textContent = txtNode.textContent;

        var padding = 0;
        var htmlElem = document.getElementsByTagName('html')[0];
        var currentFontSize = parseInt(window.getComputedStyle(htmlElem, null).getPropertyValue('font-size'), 10);
        if (currentFontSize) {
          padding = Math.floor((currentFontSize - minFontSize) / (maxFontSize - minFontSize)
            * (maxPadding - minPadding) + minPadding);
        } else {
          padding = maxPadding;
        }

        var widthValue = ( dummy.offsetWidth + padding) + 'px';
        input.setAttribute('style', 'width:' + widthValue);
        input.style.width = widthValue;
      }
    }

    // Any time the input changes, or the window resizes, adjust the size of the input box
    input.addEventListener('input', adjustInput);
    window.addEventListener('resize', adjustInput);

    // Trigger the input event once to set up the input box and dummy element
    Common.fireEvent(input, 'input');
  }

  // Retrieve the value of the input box
  function getMessage() {
    var userInput = document.getElementById(ids.userInput);
    return userInput.value;
  }

  // Set the value of the input box
  function setMessage(text) {
    var userInput = document.getElementById(ids.userInput);
    userInput.value = text;
    userInput.focus();
    Common.fireEvent(userInput, 'input');
  }

  // Send the message from the input box
  function sendMessage(newText) {
    var text;
    if (newText) {
      text = newText;
    } else {
      text = getMessage();
    }
    if (!text) {
      return;
    }
    setMessage('');

    Api.postConversationMessage(text);
  }

  // Display a message, given a message payload and a message type (user or Watson)
  function displayMessage(newPayload, typeValue) {
    var isUser = isUserMessage(typeValue);
    var textExists = (newPayload.input && newPayload.input.text)
      || (newPayload.output && newPayload.output.text);
    if (isUser !== null && textExists) {
      if (newPayload.output && Object.prototype.toString.call( newPayload.output.text ) === '[object Array]') {
        newPayload.output.text = newPayload.output.text.filter(function(item) {
          return item && item.length > 0;
        }).join(' ');
      }
      var dataObj = isUser ? newPayload.input : newPayload.output;

      if (!String(dataObj.text).trim()) {
        return;
      }
      var messageDiv = buildMessageDomElement(newPayload, isUser);


      var chatBoxElement = document.getElementById(ids.chatFlow);
      chatBoxElement.appendChild(messageDiv);
      updateChat();
	  	  	  ResetTimers();
	  StartTimers();
    }
  }

  // Determine whether a given message type is user or Watson
  function isUserMessage(typeValue) {
    if (typeValue === authorTypes.user) {
      return true;
    } else if (typeValue === authorTypes.watson) {
      return false;
    }
    return null;
  }

  // Builds the message DOM element (using auxiliary function Common.buildDomElement)
  function buildMessageDomElement(newPayload, isUser) {
    var dataObj = isUser ? newPayload.input : newPayload.output;
    var messageJson = {
      // <div class='user / watson'>
      'tagName': 'div',
      'classNames': ['message-wrapper', (isUser ? authorTypes.user : authorTypes.watson)],
      'children': [{
        // <p class='user-message / watson-message'>
        'tagName': 'p',
        'classNames': (isUser
          ? [authorTypes.user + '-message']
          : [authorTypes.watson + '-message', classes.preBar]),
        'html': (isUser ?  dataObj.text  : dataObj.text)
      }]
    };

    return Common.buildDomElement(messageJson);
  }

  // Display the chat box if it's currently hidden
  // (i.e. if this is the first message), scroll to the bottom of the chat
  function updateChat() {
    document.getElementById(ids.chatScrollWrapper).style.display = '';
    var messages = document.getElementById(ids.chatFlow).getElementsByClassName(classes.messageWrapper);
    document.getElementById(ids.chatFlow).scrollTop = messages[messages.length - 1].offsetTop;
  }

  // Set browser focus on the input box
  function focusInput() {
    document.getElementById(ids.userInput).focus();
  }
}());


(function() {
 
  Conversation.init();
  Api.initConversation();
  Conversation.focusInput();
}());


